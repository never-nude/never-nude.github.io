(() => {
  'use strict';

  const canvas = document.getElementById('neuralCanvas');
  if (!canvas) return;

  // Make keyboard shortcuts reliable in Chrome:
  // - canvas is focusable
  // - we focus it on load and on pointerdown
  canvas.tabIndex = 0;
  canvas.style.outline = 'none';
  try { document.body.tabIndex = -1; } catch {}

  const ctx = canvas.getContext('2d', { alpha:true });

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;

  function hexToRgb(hex){
    const h = String(hex||'#fff').replace('#','').trim();
    const hh = (h.length===3) ? h.split('').map(c=>c+c).join('') : h;
    const n = parseInt(hh,16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgba(hex,a){
    const {r,g,b}=hexToRgb(hex);
    return `rgba(${r},${g},${b},${clamp(a,0,1)})`;
  }
  function esc(s){
    return String(s).replace(/[&<>"']/g, (c)=>({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));
  }

  // -------------------------
  // Pathway guide (left panel)
  // -------------------------
  const PATH_TEXT = {
    'Vision': 'Thalamus → Visual (L/R) → Parietal (L/R) → PFC (L/R)',
    'Sound': 'Thalamus → Temporal/Auditory (L/R) → PFC (L/R)',
    'Smell': 'Temporal (L/R) → Hippocampus (L/R) → Amygdala (L/R)',
    'Taste': 'Insula (L/R) → Hypothalamus → ACC',
    'Touch': 'Parietal (L/R) ↔ Insula (L/R) → ACC → PFC',
    'Pain': 'Insula (L/R) → ACC → Amygdala → Hypothalamus → PFC',
    'Heat/Cold': 'Hypothalamus → Insula (L/R) → ACC',
    'Proprioception': 'Parietal (L/R) → Cerebellum → Motor/S1 (L/R)',
    'Balance': 'Cerebellum → Thalamus → Parietal',

    'Hunger': 'Hypothalamus → Insula → ACC → PFC',
    'Thirst': 'Hypothalamus → Insula → ACC → PFC',
    'Air hunger (CO₂)': 'Brainstem → Insula (L/R) → ACC → PFC (override)',
    'Heart pounding': 'Brainstem → Insula → ACC → Amygdala',
    'Nausea': 'Brainstem → Insula → Hypothalamus',
    'Fatigue': 'Brainstem → Thalamus → PFC',

    'Threat cue': 'Amygdala (L/R) → ACC → Hypothalamus → PFC',
    'Social threat': 'ACC ↔ Amygdala → PFC (evaluation / inhibition)',
    'Safety cue': 'PFC → ACC → downshift alarm pathways',
    'Bonding cue': 'Temporal ↔ Hippocampus → PFC',

    'Novelty': 'Hippocampus (L/R) → Thalamus → PFC',
    'Uncertainty': 'ACC → PFC (resolve / choose)',
    'Time pressure': 'ACC → PFC + Brainstem (urgency bias)',
    'Reward cue': 'PFC → Striatum → Motor/S1',
    'Memory cue': 'Hippocampus (L/R) → PFC',
  };

  const GUIDE = {
    el: null,
    lastUpdate: 0,
    prevStim: Object.create(null),
    lastChanged: null,
    traffic: [],
  };

  function ensureGuide(){
    if (GUIDE.el) return GUIDE.el;

    const el = document.createElement('div');
    el.id = 'dbPathGuide';
    el.style.position = 'fixed';
    el.style.left = '14px';
    el.style.top = '14px';
    el.style.bottom = '96px'; // leaves room for HUD bottom-left
    el.style.width = 'min(360px, 32vw)';
    el.style.padding = '12px 14px';
    el.style.borderRadius = '14px';
    el.style.background = 'rgba(0,0,0,0.30)';
    el.style.border = '1px solid rgba(255,255,255,0.10)';
    el.style.backdropFilter = 'blur(8px)';
    el.style.webkitBackdropFilter = 'blur(8px)';
    el.style.color = 'rgba(185,205,225,0.84)';
    el.style.font = '12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    el.style.overflow = 'auto';
    el.style.zIndex = '9999';
    el.style.pointerEvents = 'auto';

    document.body.appendChild(el);
    GUIDE.el = el;
    return el;
  }

  function getStim(){
    window.DB_STIM = (window.DB_STIM && typeof window.DB_STIM === 'object') ? window.DB_STIM : Object.create(null);
    return window.DB_STIM;
  }

  function detectLastChanged(stim){
    let changed = None = null
    changed = None
    // (placeholder; overwritten below in JS runtime)
  }

  function computeLastChanged(stim){
    let last = null;
    for (const [k,v0] of Object.entries(stim)){
      const v = clamp(Number(v0)||0, 0, 1);
      const pv = clamp(Number(GUIDE.prevStim[k])||0, 0, 1);
      if (Math.abs(v - pv) > 0.001) last = k;
      GUIDE.prevStim[k] = v;
    }
    return last;
  }

  function updateGuide(){
    const el = ensureGuide();
    const stim = getStim();
    const active = Object.entries(stim)
      .map(([k,v])=>[k, clamp(Number(v)||0,0,1)])
      .filter(([_,v])=>v>0.001)
      .sort((a,b)=>b[1]-a[1]);

    const changed = computeLastChanged(stim);
    if (changed) GUIDE.lastChanged = changed;

    const lastName = GUIDE.lastChanged;
    const lastPath = lastName ? (PATH_TEXT[lastName] || '—') : null;

    let html = '';
    html += `<div style="font-weight:700; color:rgba(210,230,245,0.92); margin-bottom:6px;">Pathway guide</div>`;
    html += `<div style="opacity:0.75; margin-bottom:10px;">Directions (left) + map (right). Use <b>S</b> or the <b>Stimuli</b> button to inject signals.</div>`;

    if (lastName){
      html += `<div style="margin:10px 0 6px; opacity:0.70;">Last input</div>`;
      html += `<div style="color:rgba(220,240,255,0.92); margin-bottom:4px;"><b>${esc(lastName)}</b></div>`;
      html += `<div style="opacity:0.86;">${esc(lastPath)}</div>`;
    }

    html += `<div style="margin:12px 0 6px; opacity:0.70;">Active stimuli</div>`;
    if (!active.length){
      html += `<div style="opacity:0.80;">None yet.</div>`;
    } else {
      for (const [name,v] of active){
        const pct = Math.round(v*100);
        const path = PATH_TEXT[name] || '—';
        html += `<div style="margin-top:8px;">
          <div style="display:flex; justify-content:space-between; gap:10px;">
            <div style="color:rgba(225,240,255,0.92);"><b>${esc(name)}</b></div>
            <div style="opacity:0.65;">${pct}%</div>
          </div>
          <div style="opacity:0.86;">${esc(path)}</div>
        </div>`;
      }
    }

    html += `<div style="margin:12px 0 6px; opacity:0.70;">Live traffic (top bundles)</div>`;
    if (!GUIDE.traffic.length){
      html += `<div style="opacity:0.80;">Quiet baseline.</div>`;
    } else {
      for (const t of GUIDE.traffic.slice(0,6)){
        html += `<div style="opacity:0.88; margin-top:6px;">${esc(t)}</div>`;
      }
    }

    html += `<div style="margin-top:12px; opacity:0.55;">
      Tip (Chrome): click the canvas once if keys feel asleep.
    </div>`;

    el.innerHTML = html;
  }

  // -------------------------
  // View controls
  // -------------------------
  const view = { yaw: 0.85, pitch: -0.40, zoom: 1.05, panX: 0, panY: 0 };
  let dragging=false, dragMode='rotate', lastX=0, lastY=0;
  let paused=false;

  function resetView(){
    view.yaw = 0.85; view.pitch = -0.40; view.zoom = 1.05; view.panX = 0; view.panY = 0;
  }

  canvas.addEventListener('pointerdown',(e)=>{
    try { canvas.focus({ preventScroll:true }); } catch {}
    canvas.setPointerCapture(e.pointerId);
    dragging=true;
    dragMode = e.shiftKey ? 'pan' : 'rotate';
    lastX=e.clientX; lastY=e.clientY;
  });
  canvas.addEventListener('pointermove',(e)=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    lastX=e.clientX; lastY=e.clientY;
    if(dragMode==='rotate'){
      view.yaw += dx*0.006;
      view.pitch += dy*0.006;
      view.pitch = clamp(view.pitch,-1.25,1.25);
    } else {
      view.panX += dx;
      view.panY += dy;
    }
  });
  const end=()=>dragging=false;
  canvas.addEventListener('pointerup',end);
  canvas.addEventListener('pointercancel',end);

  canvas.addEventListener('wheel',(e)=>{
    e.preventDefault();
    const mul = (e.deltaY>0)?0.92:1.08;
    view.zoom = clamp(view.zoom*mul,0.55,2.6);
  },{passive:false});

  window.addEventListener('keydown',(e)=>{
    const tag=(e.target&&e.target.tagName)?e.target.tagName:'';
    if(tag==='INPUT'||tag==='TEXTAREA') return;
    if(e.key==='p'||e.key==='P') paused=!paused;
    if(e.key==='r'||e.key==='R') resetView();
  },{capture:true});

  // -------------------------
  // Regions + edges
  // -------------------------
  const REGIONS = [
    { id:'PFC_L', label:'PFC L', color:'#74d4ff', p:[-0.72,  0.48,  0.85] },
    { id:'PFC_R', label:'PFC R', color:'#74d4ff', p:[ 0.72,  0.48,  0.85] },
    { id:'M1_L',  label:'Motor/S1 L', color:'#9ff0d0', p:[-0.45,  0.28,  0.30] },
    { id:'M1_R',  label:'Motor/S1 R', color:'#9ff0d0', p:[ 0.45,  0.28,  0.30] },
    { id:'PAR_L', label:'Parietal L', color:'#7dfc9a', p:[-0.55,  0.34, -0.05] },
    { id:'PAR_R', label:'Parietal R', color:'#7dfc9a', p:[ 0.55,  0.34, -0.05] },
    { id:'TMP_L', label:'Temporal/Aud L', color:'#b98cff', p:[-0.92,  0.05,  0.05] },
    { id:'TMP_R', label:'Temporal/Aud R', color:'#b98cff', p:[ 0.92,  0.05,  0.05] },
    { id:'OCC_L', label:'Visual L', color:'#ffb86b', p:[-0.82,  0.34, -0.90] },
    { id:'OCC_R', label:'Visual R', color:'#ffb86b', p:[ 0.82,  0.34, -0.90] },
    { id:'INS_L', label:'Insula L', color:'#66ffd6', p:[-0.32,  0.02,  0.18] },
    { id:'INS_R', label:'Insula R', color:'#66ffd6', p:[ 0.32,  0.02,  0.18] },
    { id:'ACC',  label:'ACC', color:'#e7f0ff', p:[0.00, 0.32, 0.55] },
    { id:'CALL', label:'Corpus callosum', color:'#d7dbe6', p:[0.00, 0.44, 0.35] },
    { id:'THAL', label:'Thalamus', color:'#cbd5e1', p:[0.00, 0.16, 0.10] },
    { id:'HYPO', label:'Hypothalamus', color:'#ff7aa2', p:[0.00, 0.00, 0.20] },
    { id:'AMY_L', label:'Amygdala L', color:'#ff5a6a', p:[-0.18, -0.04, 0.08] },
    { id:'AMY_R', label:'Amygdala R', color:'#ff5a6a', p:[ 0.18, -0.04, 0.08] },
    { id:'HIP_L', label:'Hippocampus L', color:'#52ffd0', p:[-0.20, -0.12,-0.12] },
    { id:'HIP_R', label:'Hippocampus R', color:'#52ffd0', p:[ 0.20, -0.12,-0.12] },
    { id:'STR_L', label:'Striatum L', color:'#ffd66b', p:[-0.28,  0.06,  0.30] },
    { id:'STR_R', label:'Striatum R', color:'#ffd66b', p:[ 0.28,  0.06,  0.30] },
    { id:'CBL', label:'Cerebellum', color:'#9aa7ff', p:[0.00, -0.40, -0.95] },
    { id:'BST', label:'Brainstem', color:'#9aa0aa', p:[0.00, -0.70, -0.35] },
  ];
  const R = Object.fromEntries(REGIONS.map(r=>[r.id,r]));

  const E = (a,b,w)=>({a,b,w,fibers:[]});
  const EDGES = [
    E('THAL','OCC_L',0.9), E('THAL','OCC_R',0.9),
    E('THAL','TMP_L',0.8), E('THAL','TMP_R',0.8),
    E('THAL','PAR_L',0.7), E('THAL','PAR_R',0.7),
    E('THAL','INS_L',0.6), E('THAL','INS_R',0.6),
    E('THAL','PFC_L',0.4), E('THAL','PFC_R',0.4),

    E('OCC_L','PAR_L',0.55), E('OCC_R','PAR_R',0.55),
    E('PAR_L','PFC_L',0.55), E('PAR_R','PFC_R',0.55),
    E('TMP_L','PFC_L',0.45), E('TMP_R','PFC_R',0.45),

    E('AMY_L','ACC',0.65), E('AMY_R','ACC',0.65),
    E('AMY_L','HYPO',0.75), E('AMY_R','HYPO',0.75),
    E('AMY_L','PFC_L',0.45), E('AMY_R','PFC_R',0.45),
    E('HIP_L','PFC_L',0.45), E('HIP_R','PFC_R',0.45),
    E('ACC','PFC_L',0.55), E('ACC','PFC_R',0.55),

    E('PFC_L','STR_L',0.65), E('PFC_R','STR_R',0.65),
    E('STR_L','M1_L',0.70), E('STR_R','M1_R',0.70),

    E('INS_L','ACC',0.55), E('INS_R','ACC',0.55),
    E('BST','INS_L',0.55), E('BST','INS_R',0.55),
    E('BST','HYPO',0.65),  E('HYPO','BST',0.55),

    E('M1_L','CBL',0.40), E('M1_R','CBL',0.40),
    E('CBL','M1_L',0.40), E('CBL','M1_R',0.40),

    E('PFC_L','CALL',0.30), E('CALL','PFC_R',0.30),
    E('PFC_R','CALL',0.30), E('CALL','PFC_L',0.30),
    E('PAR_L','CALL',0.24), E('CALL','PAR_R',0.24),
    E('PAR_R','CALL',0.24), E('CALL','PAR_L',0.24),
    E('TMP_L','CALL',0.20), E('CALL','TMP_R',0.20),
    E('TMP_R','CALL',0.20), E('CALL','TMP_L',0.20),
    E('OCC_L','CALL',0.20), E('CALL','OCC_R',0.20),
    E('OCC_R','CALL',0.20), E('CALL','OCC_L',0.20),
  ];

  // -------------------------
  // Node clusters + fibers (denser bundles)
  // -------------------------
  const NODES_PER = 18;
  const nodes=[];
  const regionIdx={};

  function randn(){ return (Math.random()+Math.random()+Math.random()+Math.random()-2.0)*0.5; }

  for(const r of REGIONS){
    regionIdx[r.id]=[];
    for(let i=0;i<NODES_PER;i++){
      const s=0.07;
      const p=[r.p[0]+randn()*s, r.p[1]+randn()*s, r.p[2]+randn()*s];
      const idx=nodes.length;
      nodes.push({ rid:r.id, p, seed:Math.random()*10 });
      regionIdx[r.id].push(idx);
    }
  }

  const pick=(arr)=>arr[Math.floor(Math.random()*arr.length)];

  const FIBERS=9; // more strands per tract
  for(const e of EDGES){
    const A=regionIdx[e.a]||[], B=regionIdx[e.b]||[];
    for(let i=0;i<FIBERS;i++){
      if(!A.length||!B.length) break;
      e.fibers.push([ pick(A), pick(B), (i-(FIBERS-1)/2) ]);
    }
  }
})();
  // -------------------------
  // Stimuli mapping
  // -------------------------
  const STIM_MAP = {
    'Vision':         [['THAL',0.8],['OCC_L',1.0],['OCC_R',1.0],['PFC_L',0.2],['PFC_R',0.2]],
    'Sound':          [['THAL',0.6],['TMP_L',1.0],['TMP_R',1.0]],
    'Smell':          [['TMP_L',0.7],['TMP_R',0.7],['HIP_L',0.4],['HIP_R',0.4],['AMY_L',0.25],['AMY_R',0.25]],
    'Taste':          [['INS_L',0.7],['INS_R',0.7],['HYPO',0.25]],
    'Touch':          [['PAR_L',0.7],['PAR_R',0.7],['M1_L',0.35],['M1_R',0.35],['INS_L',0.25],['INS_R',0.25]],
    'Pain':           [['AMY_L',0.9],['AMY_R',0.9],['ACC',0.8],['INS_L',0.7],['INS_R',0.7],['HYPO',0.5]],
    'Heat/Cold':      [['HYPO',0.8],['INS_L',0.35],['INS_R',0.35],['ACC',0.3]],
    'Proprioception': [['PAR_L',0.6],['PAR_R',0.6],['CBL',0.4]],
    'Balance':        [['CBL',0.9],['THAL',0.25]],
    'Hunger':         [['HYPO',1.0],['INS_L',0.35],['INS_R',0.35],['ACC',0.25]],
    'Thirst':         [['HYPO',1.0],['INS_L',0.35],['INS_R',0.35],['ACC',0.25]],
    'Air hunger (CO₂)':[["BST",1.0],['INS_L',0.8],['INS_R',0.8],['ACC',0.45],['AMY_L',0.25],['AMY_R',0.25]],
    'Heart pounding': [['BST',0.8],['INS_L',0.55],['INS_R',0.55],['ACC',0.35],['AMY_L',0.20],['AMY_R',0.20]],
    'Nausea':         [['BST',0.7],['INS_L',0.7],['INS_R',0.7],['HYPO',0.4]],
    'Fatigue':        [['BST',0.55],['THAL',0.35],['PFC_L',0.20],['PFC_R',0.20]],
    'Threat cue':     [['AMY_L',1.0],['AMY_R',1.0],['ACC',0.5],['HYPO',0.5]],
    'Social threat':  [['AMY_L',0.8],['AMY_R',0.8],['ACC',0.7],['PFC_L',0.3],['PFC_R',0.3]],
    'Safety cue':     [['PFC_L',0.4],['PFC_R',0.4],['ACC',0.15],['HYPO',0.2]],
    'Bonding cue':    [['TMP_L',0.3],['TMP_R',0.3],['PFC_L',0.3],['PFC_R',0.3],['HIP_L',0.2],['HIP_R',0.2]],
    'Novelty':        [['HIP_L',0.9],['HIP_R',0.9],['THAL',0.4],['PFC_L',0.25],['PFC_R',0.25]],
    'Uncertainty':    [['ACC',1.0],['PFC_L',0.55],['PFC_R',0.55]],
    'Time pressure':  [['ACC',0.5],['PFC_L',0.7],['PFC_R',0.7],['BST',0.25]],
    'Reward cue':     [['STR_L',0.9],['STR_R',0.9],['PFC_L',0.25],['PFC_R',0.25]],
    'Memory cue':     [['HIP_L',0.9],['HIP_R',0.9],['PFC_L',0.2],['PFC_R',0.2]],
  };

  // activation
  const act={}; for(const r of REGIONS) act[r.id]=0;
  act.THAL=0.22; act.PFC_L=0.08; act.PFC_R=0.08; act.CALL=0.02;

  // packets
  const packets=[]; let lastSpawn=0;

  // canvas sizing
  let W=0,H=0,dpr=1;

  function resize(){
    dpr=Math.max(1, window.devicePixelRatio||1);
    W=window.innerWidth; H=window.innerHeight;
    canvas.width=Math.floor(W*dpr);
    canvas.height=Math.floor(H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize',resize);
  resize();

  // layout: center the map in the space to the right of the guide panel
  const LAYOUT = { leftPad: 0, availW: 0, cx: 0, cy: 0, scale: 1 };

  function computeLayout(){
    const guide = ensureGuide();
    const gr = guide.getBoundingClientRect();
    const leftPad = gr.right + 22;
    const rightPad = 14;
    const availW = Math.max(240, W - leftPad - rightPad);

    LAYOUT.leftPad = leftPad;
    LAYOUT.availW  = availW;
    LAYOUT.cx = leftPad + availW*0.5 + view.panX;
    LAYOUT.cy = H*0.5 + view.panY;
    LAYOUT.scale = Math.min(availW, H) * 0.45 * view.zoom;
  }

  // 3D projection
  function rotY(p,a){ const [x,y,z]=p; const c=Math.cos(a), s=Math.sin(a); return [x*c+z*s, y, -x*s+z*c]; }
  function rotX(p,a){ const [x,y,z]=p; const c=Math.cos(a), s=Math.sin(a); return [x, y*c-z*s, y*s+z*c]; }

  function project(p){
    let q=rotY(p,view.yaw); q=rotX(q,view.pitch);
    const z=q[2];
    const persp=1/(1+z*0.55);
    const scale=LAYOUT.scale;
    return { x: LAYOUT.cx + q[0]*scale*persp, y: LAYOUT.cy - q[1]*scale*persp, persp };
  }

  function bez(ax,ay,bx,by,b){
    const mx=(ax+bx)/2,my=(ay+by)/2;
    const dx=bx-ax,dy=by-ay; const len=Math.hypot(dx,dy)||1;
    const nx=-dy/len,ny=dx/len;
    const cx=mx+nx*b, cy=my+ny*b;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.quadraticCurveTo(cx,cy,bx,by);
  }

  // stimulus store
  window.DB_STIM = (window.DB_STIM && typeof window.DB_STIM==='object') ? window.DB_STIM : Object.create(null);

  function simStep(){
    const input={}; let any=false;
    for(const [name,v0] of Object.entries(window.DB_STIM)){
      const v=clamp(Number(v0)||0,0,1);
      if(v<=0) continue;
      any=true;
      const map=STIM_MAP[name]; if(!map) continue;
      for(const [rid,w] of map) input[rid]=(input[rid]||0)+v*w;
    }

    const next={}; for(const r of REGIONS) next[r.id]=act[r.id]*0.86;
    next.THAL += 0.04; next.CALL += 0.01;

    for(const e of EDGES){
      const a=act[e.a]||0;
      if(a<=0) continue;
      next[e.b] += a*(e.w*0.18);
    }
    for(const [rid,v] of Object.entries(input)){
      next[rid]=(next[rid]||0)+v*0.55;
    }
    for(const r of REGIONS) act[r.id]=clamp(next[r.id]||0,0,1);

    // packet spawning
    const now=performance.now();
    if(now-lastSpawn>180){
      lastSpawn=now;
      const scored=[];
      for(let i=0;i<EDGES.length;i++){
        const e=EDGES[i];
        const s=(act[e.a]||0)*(0.35+0.65*(act[e.b]||0))*e.w;
        if(s>0.02) scored.push([s,i]);
      }
      scored.sort((a,b)=>b[0]-a[0]);
      const k=any?5:2;
      for(let j=0;j<Math.min(k,scored.length);j++){
        const ei=scored[j][1]; const e=EDGES[ei];
        if(!e.fibers.length) continue;
        const fi=Math.floor(Math.random()*e.fibers.length);
        packets.push({ei,fi,t:0,speed:0.8+Math.random()*0.8});
      }
      if(packets.length>80) packets.splice(0,packets.length-80);
    }
  }

  const screen=new Array(nodes.length);
  let lastGuideUpdate = 0;

  function draw(){
    computeLayout();

    ctx.fillStyle='#050608';
    ctx.fillRect(0,0,W,H);

    // project nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i];
      const a=act[n.rid]||0;
      const t=performance.now()*0.001+n.seed;
      const jig=0.008+a*0.010;
      const p=[n.p[0]+Math.sin(t)*jig, n.p[1]+Math.cos(t*0.9)*jig, n.p[2]];
      screen[i]=project(p);
    }

    // faint scaffold
    ctx.lineCap='round';
    for(const e of EDGES){
      const ra=R[e.a], rb=R[e.b];
      const A=project(ra.p), B=project(rb.p);
      ctx.strokeStyle='rgba(190,205,225,0.06)';
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }

    // active bundles: pick top edges
    const scored=[];
    for(let i=0;i<EDGES.length;i++){
      const e=EDGES[i];
      const s=(act[e.a]||0)*(0.35+0.65*(act[e.b]||0))*e.w;
      scored.push([s,i]);
    }
    scored.sort((a,b)=>b[0]-a[0]);
    const top=scored.slice(0,36);

    // capture traffic list for the guide
    GUIDE.traffic = top
      .filter(([s,_])=>s>0.02)
      .slice(0,10)
      .map(([_,ei])=>{
        const e=EDGES[ei];
        const a=R[e.a]?.label||e.a;
        const b=R[e.b]?.label||e.b;
        return `${a} → ${b}`;
      });

    for(const [s,ei] of top){
      if(s<0.012) break;
      const e=EDGES[ei];
      const ra=R[e.a], rb=R[e.b];
      const alpha=clamp(0.12+s*1.8,0.12,0.88);
      const width=clamp(1.0+s*9.0,1.0,6.0);

      for(let k=0;k<e.fibers.length;k++){
        const [ia,ib,bendIdx]=e.fibers[k];
        const A=screen[ia], B=screen[ib];
        const grad=ctx.createLinearGradient(A.x,A.y,B.x,B.y);
        grad.addColorStop(0, rgba(ra.color,alpha));
        grad.addColorStop(1, rgba(rb.color,alpha));
        ctx.strokeStyle=grad;
        ctx.lineWidth=width*(0.52+0.12*k);
        bez(A.x,A.y,B.x,B.y,bendIdx*6.0);
        ctx.stroke();
      }
    }

    // packets
    for(let i=packets.length-1;i>=0;i--){
      const p=packets[i];
      const e=EDGES[p.ei]; const f=e.fibers[p.fi];
      const A=screen[f[0]], B=screen[f[1]];
      p.t += (1/60)*p.speed;
      if(p.t>=1.0){ packets.splice(i,1); continue; }
      const x=lerp(A.x,B.x,p.t), y=lerp(A.y,B.y,p.t);
      ctx.fillStyle='rgba(230,245,255,0.90)';
      ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
    }

    // nodes
    for(let i=0;i<nodes.length;i++){
      const n=nodes[i]; const r=R[n.rid];
      const a=clamp(act[n.rid]||0,0,1);
      const P=screen[i];
      ctx.fillStyle=rgba(r.color, 0.18+a*0.62);
      ctx.beginPath(); ctx.arc(P.x,P.y, 1.1+a*1.6, 0, Math.PI*2); ctx.fill();
    }

    // labels (subtle)
    ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
    for(const r of REGIONS){
      const a=clamp(act[r.id]||0,0,1);
      const P=project(r.p);
      ctx.fillStyle=`rgba(210,225,240,${0.18+a*0.55})`;
      ctx.fillText(r.label, P.x+8, P.y-8);
    }

    ctx.fillStyle='rgba(200,210,225,0.55)';
    ctx.fillText(paused ? 'PAUSED (P)' : 'running (P)', 18, 22);

    // update guide at low frequency (keeps it stable)
    const n = performance.now();
    if (n - lastGuideUpdate > 250) {
      lastGuideUpdate = n;
      updateGuide();
    }
  }

  function loop(){
    if(!paused) simStep();
    draw();
    requestAnimationFrame(loop);
  }

  // Focus on load (helps Chrome)
  window.addEventListener('load', () => {
    try { canvas.focus({ preventScroll:true }); } catch {}
    try { ensureGuide(); updateGuide(); } catch {}
  }, { once:true });

  requestAnimationFrame(loop);
})();