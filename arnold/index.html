<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arnold</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #hud {
      position: fixed; top: 12px; left: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.88);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      color: #fff;
      font: 13px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      user-select: none;
      z-index: 10;
      min-width: 380px;
      white-space: pre;
    }
    #hud .build { font-size: 16px; font-weight: 700; letter-spacing: 0.3px; }
    #hud .row { opacity: 0.92; }
    #fallback {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      color: #fff;
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      padding: 24px; text-align: center;
      z-index: 20;
    }
  
/* HUD COMPACT TOGGLE (B11-0002) */
#hud, .hud { pointer-events: none; }
#hud.hud_compact #helpLine, .hud.hud_compact #helpLine { display: none; }
#hud.hud_compact #benchLine, .hud.hud_compact #benchLine { max-height: 220px; overflow: hidden; }
#hud.hud_compact, .hud.hud_compact { max-width: 560px; }

</style>
</head>
<body>
  <div id="hud">
    <div class="build" id="buildLine">BUILD:</div>
    <div class="row" id="urlLine"></div>
    <div class="row" id="statsLine"></div>
    <div class="row" id="memLine"></div>
    <div class="row" id="persistLine"></div>
    <div class="row" id="benchLine"></div>
    <div class="row" id="sysLine"></div>
    <div class="row" id="actionLine"></div>
    <div class="row" id="helpLine"></div>
    <div class="row" id="fpsLine"></div>
  </div>

  <div id="fallback"></div>

  <script type="module">
    const BUILD = "NN3D-B11-0006"; // Persistence (Save/Load) + associative memory
    const STORAGE_KEY = "nn3d_state_v1";
      const AUTOLOAD_KEY = "arnold_autoload_v1";
      let autoLoadOn = false;
      try { autoLoadOn = JSON.parse(localStorage.getItem(AUTOLOAD_KEY) || "false"); } catch(e) { autoLoadOn = false; }
      let autoLoadAttempted = false;

      let sysToast = "";
      let sysToastUntil = 0;
      function toast(msg, ms=2000) {
        sysToast = msg;
        sysToastUntil = performance.now() + ms;
      }

    // For persistence to make sense, the *world* must be stable across refresh.
    // We lock the topology/positions by using a fixed seed for world generation.
    const WORLD_SEED = 1337;

    const buildLine   = document.getElementById('buildLine');
    const urlLine     = document.getElementById('urlLine');
    const statsLine   = document.getElementById('statsLine');
    const memLine     = document.getElementById('memLine');
    const persistLine = document.getElementById('persistLine');
    const benchLine = document.getElementById('benchLine');
    const sysLine = document.getElementById('sysLine');

      // HUD compact toggle (B11-0002)
      const HUD_UI_KEY = "arnold_hud_ui_v1";
      const hudEl = document.getElementById('hud') || document.querySelector('.hud');
      let hudCompact = true; // default: compact
      try { hudCompact = JSON.parse(localStorage.getItem(HUD_UI_KEY) || "true"); } catch (e) { hudCompact = true; }

      function applyHudUi() {
        if (!hudEl) return;
        hudEl.classList.toggle("hud_compact", !!hudCompact);
      }

      function toggleHudUi() {
        hudCompact = !hudCompact;
        try { localStorage.setItem(HUD_UI_KEY, JSON.stringify(hudCompact)); } catch (e) {}
        applyHudUi();
        if (typeof toast === "function") toast("HUD " + (hudCompact ? "COMPACT" : "FULL") + " (H)", 1800);
      }

      window.addEventListener('keydown', (ev) => {
        if (ev.code === 'KeyH') { toggleHudUi(); ev.preventDefault(); }
      
    if (ev.code === 'KeyP') {
      window.__arnoldPaused = !window.__arnoldPaused;
      if (typeof toast === 'function') toast('PAUSE ' + (window.__arnoldPaused ? 'ON' : 'OFF'), 1200);
      if (typeof setSysLine === 'function') setSysLine('pause ' + (window.__arnoldPaused ? 'ON' : 'OFF'));
      return;
    }
}, true);

      applyHudUi();
    sysLine.style.fontWeight = "800";
    const actionLine  = document.getElementById('actionLine');
    const helpLine    = document.getElementById('helpLine');
    const fpsLine     = document.getElementById('fpsLine');
    const fallback    = document.getElementById('fallback');

    buildLine.textContent = `Arnold  |  BUILD: ${BUILD}`;
    urlLine.textContent = location.href;
    helpLine.textContent =
      "Click=stimulate  |  L=toggle live learning  |  R=reset all\n" +
      "1-3=IMPRINT pattern  |  Shift+1-3=RECALL  |  S=SAVE  |  O=LOAD  |  A=AUTOLOAD  |  C=CLEAR  |  H=HUD  |  V=VIZ  |  M=MEM  |  U=CAP(75) Shift+U=CAP(80)  |  T=BENCH(75) Shift+T=BENCH(80)  |  Y=SWEEP(75) Shift+Y=SWEEP(80)";

    console.log(`[Arnold] BUILD ${BUILD}`, location.href);

    // CDN fallback chain
    const threeUrls = [
      'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
      'https://unpkg.com/three@0.160.0/build/three.module.js',
    ];

    let p = import(threeUrls[0]);
    for (let i = 1; i < threeUrls.length; i++) p = p.catch(() => import(threeUrls[i]));

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function mulberry32(seed) {
      let a = seed >>> 0;
      return function() {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function randnFrom(rnd) {
      // Box-Muller
      let u = 0, v = 0;
      while (u === 0) u = rnd();
      while (v === 0) v = rnd();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function randomPointInSphere(radius) {
      // (pattern generation only; doesn't need to be seeded)
      for (;;) {
        const x = (Math.random() * 2 - 1) * radius;
        const y = (Math.random() * 2 - 1) * radius;
        const z = (Math.random() * 2 - 1) * radius;
        if (x*x + y*y + z*z <= radius*radius) return [x, y, z];
      }
    }

    function encodeBits(int8arr) {
      // -1 -> 0, +1 -> 1
      let s = "";
      for (let i = 0; i < int8arr.length; i++) s += (int8arr[i] > 0 ? "1" : "0");
      return s;
    }

    function decodeBits(bits, n) {
      const out = new Int8Array(n);
      const L = Math.min(bits.length, n);
      for (let i = 0; i < L; i++) out[i] = (bits.charCodeAt(i) === 49) ? 1 : -1; // '1' = 49
      for (let i = L; i < n; i++) out[i] = -1;
      return out;
    }

    function fmtTime(ms) {
      if (!ms) return "--";
      try { return new Date(ms).toLocaleTimeString(); }
      catch { return String(ms); }
    }

    p.then((THREE) => {
      // ---------- Scene ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 200);
      camera.position.set(0, 0, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.display = 'block';
      document.body.appendChild(renderer.domElement);

      // ---------- Network geometry ----------
      const NODE_COUNT = 260;
      const K = 6;
      const R = 2.4;

      const EDGE_COUNT = NODE_COUNT * K;

      // Seeded RNG for world stability
      const randWorld = mulberry32(WORLD_SEED);

      // Node positions
      const positions = new Float32Array(NODE_COUNT * 3);
      for (let i = 0; i < NODE_COUNT; i++) {
        const u = randWorld();
        const v = randWorld();
        const w = randWorld();

        const r = Math.cbrt(u) * R;
        const theta = 2 * Math.PI * v;
        const phi = Math.acos(2 * w - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i*3+0] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;
      }

      // Edges (pairs), also seeded
      const aIdx = new Uint16Array(EDGE_COUNT);
      const bIdx = new Uint16Array(EDGE_COUNT);
      for (let i = 0; i < NODE_COUNT; i++) {
        for (let k = 0; k < K; k++) {
          const e = i * K + k;
          let j = (i + 1 + Math.floor(randWorld() * (NODE_COUNT - 1))) % NODE_COUNT;
          aIdx[e] = i;
          bIdx[e] = j;
        }
      }

      // Edge vertex positions (2 vertices per segment)
      const edgePos = new Float32Array(EDGE_COUNT * 2 * 3);
      for (let e = 0; e < EDGE_COUNT; e++) {
        const u = aIdx[e], v = bIdx[e];
        const o = e * 6;
        edgePos[o+0] = positions[u*3+0];
        edgePos[o+1] = positions[u*3+1];
        edgePos[o+2] = positions[u*3+2];
        edgePos[o+3] = positions[v*3+0];
        edgePos[o+4] = positions[v*3+1];
        edgePos[o+5] = positions[v*3+2];
      }

      // Node colors
      let nodeColors = new Float32Array(NODE_COUNT * 3);
      for (let i = 0; i < NODE_COUNT; i++) {
        nodeColors[i*3+0] = 0.15;
        nodeColors[i*3+1] = 0.15;
        nodeColors[i*3+2] = 0.15;
      }

      const nodesGeo = new THREE.BufferGeometry();
      nodesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      nodesGeo.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));

      const nodesMat = new THREE.PointsMaterial({
        size: 0.055,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
      });

      const nodes = new THREE.Points(nodesGeo, nodesMat);


// VIZ_NODE_COLOR_V1
// VIZ_ACTION_FLASH_V1 (K toggles action-flash colors)
let __vizFlashOn = false;
let __vizFlashUntil = 0;
let __vizFlashRGB = [0.9, 0.9, 0.9];
let __vizFlashLastActive = false;
const __VIZ_FLASH_MS = 450;

function __arnoldEnsureColors() {
  if (!nodesGeo.getAttribute('color')) {
    const n = nodesGeo.getAttribute('position').count;
    const cols = new Float32Array(n * 3);
    cols.fill(0.7);
    nodesGeo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
  }
  if (nodesMat && nodesMat.vertexColors !== true) nodesMat.vertexColors = true;
}

function __arnoldFlash(rgb, ms = __VIZ_FLASH_MS) {
  __vizFlashRGB = rgb;
  __vizFlashUntil = performance.now() + ms;
}

window.addEventListener('keydown', (ev) => {
  if (ev.code === 'KeyK') {
    __vizFlashOn = !__vizFlashOn;
    console.log(`[Arnold] VIZ flash ${__vizFlashOn ? 'ON' : 'OFF'}`);
    return;
  }
  if (!__vizFlashOn) return;

  // slot flashes (imprint = bold, recall = lighter)
  if (ev.code === 'Digit1') __arnoldFlash(ev.shiftKey ? [1.0, 0.5, 0.5] : [1.0, 0.15, 0.15]);
  if (ev.code === 'Digit2') __arnoldFlash(ev.shiftKey ? [1.0, 0.85, 0.5] : [1.0, 0.65, 0.15]);
  if (ev.code === 'Digit3') __arnoldFlash(ev.shiftKey ? [0.85, 0.5, 1.0] : [0.65, 0.15, 1.0]);

  if (ev.code === 'KeyC') __arnoldFlash([0.95, 0.95, 0.95], 250);
  if (ev.code === 'KeyR') __arnoldFlash([0.25, 0.65, 1.0], 250);
  if (ev.code === 'KeyU') __arnoldFlash(ev.shiftKey ? [0.2, 1.0, 0.6] : [0.2, 1.0, 0.2], 450);
}, { passive: true });
 // (V toggles: OFF → ACT → STIM)
// VIZ_MEM_VIEW_V1: memory-slot coloring toggle (M)


let vizMemOn = false;

const VIZ = { OFF: 0, ACT: 1, STIM: 2 };
let vizMode = VIZ.OFF;
let vizDirty = true;

const __NODE_COUNT = (typeof NODE_COUNT !== "undefined")
  ? NODE_COUNT
  : ((nodes.geometry && nodes.geometry.getAttribute)
      ? nodes.geometry.getAttribute("position").count
      : 0);

// VIZ_NODE_COLOR_BIND_V2: bind nodeColors to the geometry attribute (single source of truth)
const nodeColorAttr = (nodes.geometry.getAttribute('color') || (() => {
  const a = new THREE.BufferAttribute(new Float32Array(__NODE_COUNT * 3), 3);
  nodes.geometry.setAttribute('color', a);
  return a;
})());
nodeColors = nodeColorAttr.array;

nodes.geometry.setAttribute("color", nodeColorAttr);

if (nodes.material) {
  nodes.material.vertexColors = true;
  nodes.material.needsUpdate = true;
}

function vizSetAll(r,g,b){
  for (let i = 0; i < __NODE_COUNT; i++) {
    const k = i * 3;
    nodeColors[k+0] = r;
    nodeColors[k+1] = g;
    nodeColors[k+2] = b;
  }
}

vizSetAll(0.85, 0.85, 0.85);
nodeColorAttr.needsUpdate = true;

function vizName(){
  return (vizMode === VIZ.OFF) ? "OFF" : (vizMode === VIZ.ACT) ? "ACT" : "STIM";
}

function vizToggle(){
  vizMode = (vizMode + 1) % 3;
  vizDirty = true;
  const name = vizName();
  if (typeof lastAction !== "undefined") lastAction = "viz " + name;
  if (typeof toast === "function") toast("VIZ " + name + " (V)", 1200);
}

window.addEventListener("keydown", (ev) => {
  if (ev.code === "KeyV") { vizToggle(); ev.preventDefault(); }
}, true);

function vizTick(){
  if (__NODE_COUNT <= 0) return;

  if (vizMode === VIZ.OFF) {
    if (vizDirty) {
      vizSetAll(0.85, 0.85, 0.85);
      nodeColorAttr.needsUpdate = true;
      vizDirty = false;
    }
    return;
  }

  if (vizMode === VIZ.ACT) {
    for (let i = 0; i < __NODE_COUNT; i++) {
      const a0 = (typeof act !== "undefined") ? act[i] : 0;
      const x = Math.max(-1, Math.min(1, a0));
      const m = Math.pow(Math.abs(x), 0.60); // visibility gain
      let r, g, b;
      if (x >= 0) {
        r = 0.15 + 0.85 * m;
        g = 0.15 + 0.25 * (1 - m);
        b = 0.15 + 0.25 * (1 - m);
      } else {
        b = 0.15 + 0.85 * m;
        g = 0.15 + 0.25 * (1 - m);
        r = 0.15 + 0.25 * (1 - m);
      }
      const k = i * 3;
      nodeColors[k+0] = r;
      nodeColors[k+1] = g;
      nodeColors[k+2] = b;
    }
    nodeColorAttr.needsUpdate = true;
    vizDirty = false;
    return;
  }

  // VIZ.STIM
  for (let i = 0; i < __NODE_COUNT; i++) {
    const v0 = (typeof stim !== "undefined") ? stim[i] : 0;
    const t = Math.max(0, Math.min(1, v0)); // clamp
    const r = 0.12 + 0.25 * (1 - t);
    const g = 0.12 + 0.88 * t;
    const b = 0.12 + 0.25 * (1 - t);
    const k = i * 3;
    nodeColors[k+0] = r;
    nodeColors[k+1] = g;
    nodeColors[k+2] = b;
  }
  nodeColorAttr.needsUpdate = true;
  vizDirty = false;
}
      // Edge colors
      const edgeColors = new Float32Array(EDGE_COUNT * 2 * 3);
      for (let i = 0; i < edgeColors.length; i += 3) {
        edgeColors[i+0] = 0.05;
        edgeColors[i+1] = 0.08;
        edgeColors[i+2] = 0.18;
      }

      const edgesGeo = new THREE.BufferGeometry();
      edgesGeo.setAttribute('position', new THREE.BufferAttribute(edgePos, 3));
      edgesGeo.setAttribute('color', new THREE.BufferAttribute(edgeColors, 3));

      const edgesMat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.68,
      });

      const edgeLines = new THREE.LineSegments(edgesGeo, edgesMat);

      const group = new THREE.Group();
      group.add(edgeLines);
      group.add(nodes);
      scene.add(group);

      // Faint sphere
      const glowGeo = new THREE.SphereGeometry(R*1.02, 32, 32);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x224466, transparent: true, opacity: 0.12 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      // Render stability (Safari): prevent transparent depth-write occlusion + force render order
      nodesMat.depthWrite = false;
      edgesMat.depthWrite = false;
      glowMat.depthWrite = false;

      glow.renderOrder = -10;
      edgeLines.renderOrder = 0;
      nodes.renderOrder = 1;
      group.add(glow);

      // ---------- Click beacon (input visibility) ----------
      const clickBeaconGeo = new THREE.SphereGeometry(0.14, 16, 16);
      const clickBeaconMat = new THREE.MeshBasicMaterial({ color: 0xffaa33, transparent: true, opacity: 0.0 });
      clickBeaconMat.depthTest = false;
      clickBeaconMat.depthWrite = false;

      const clickBeacon = new THREE.Mesh(clickBeaconGeo, clickBeaconMat);
      clickBeacon.renderOrder = 20;
      group.add(clickBeacon);

      let clickPulse = 0.0; // 0..1
      // ---------- Learning engine ----------
      const act = new Float32Array(NODE_COUNT);
      const actNext = new Float32Array(NODE_COUNT);
      const stim = new Float32Array(NODE_COUNT);
      const sum = new Float32Array(NODE_COUNT);

      const w = new Float32Array(EDGE_COUNT);
      const wMax = 2.0;

      let liveLearningOn = false;
      const stimDecay = 0.90;
      const noiseAmp = 0.006; // uses Math.random noise (fine)
      const leak = 0.20;
      const gain = 1.25;

      const lrLive = 0.0007;
      const wDecay = 0.0030;

      const patRadius = R * 0.65;
      const lrStore = 0.10;
      const storeRepeats = 3;
      const cueFrac = 0.22;
      const cueAmp = 1.6;
      const settleSteps = 36;

      let lastAction = "ready";
      let glStatus = "OK";
      renderer.domElement.addEventListener("webglcontextlost", (e) => {
        e.preventDefault();
        glStatus = "LOST";
        lastAction = "WEBGL CONTEXT LOST";
      }, false);
      renderer.domElement.addEventListener("webglcontextrestored", () => {
        glStatus = "RESTORED";
        lastAction = "WEBGL CONTEXT RESTORED (reload recommended)";
      }, false);
      let lastStim = -1;

      /** @type {Array<null | {p:Int8Array, center:[number,number,number], radius:number, onFrac:number}>} */
      const patterns = [null, null, null];
      let targetSlot = -1;

      const persist = {
        present: false,
        savedAt: null,
        loadedAt: null,
        lastError: null,
      };

      function resetAll() {
        liveLearningOn = false; // safe default (toggle with L)
        act.fill(0);
        actNext.fill(0);
        stim.fill(0);

        // deterministic-ish initial weights on first load (seeded world RNG progressed to here)
        // and variable weights on subsequent resets (that's fine).
        for (let e = 0; e < EDGE_COUNT; e++) w[e] = randnFrom(randWorld) * 0.15;

        patterns[0] = patterns[1] = patterns[2] = null;
        targetSlot = -1;
        lastStim = -1;
        lastAction = "reset all (liveLearn OFF)";
      }

      function stepOnce(opts = { noise: noiseAmp, learn: liveLearningOn }) {
        const noise = opts.noise ?? noiseAmp;
        const learn = opts.learn ?? liveLearningOn;

        for (let i = 0; i < NODE_COUNT; i++) stim[i] *= stimDecay;

        for (let i = 0; i < NODE_COUNT; i++) {
          // noise uses Math.random -> alive + non-repeating; doesn't affect persistence correctness
          sum[i] = stim[i] + noise * randnFrom(Math.random);
        }

        for (let e = 0; e < EDGE_COUNT; e++) {
          const u = aIdx[e], v = bIdx[e];
          const we = w[e];
          const au = act[u], av = act[v];
          sum[u] += we * av;
          sum[v] += we * au;
        }

        for (let i = 0; i < NODE_COUNT; i++) {
          actNext[i] = Math.tanh(gain * (leak * act[i] + sum[i]));
        }

        if (learn) {
          for (let e = 0; e < EDGE_COUNT; e++) {
            const u = aIdx[e], v = bIdx[e];
            let nw = w[e] + lrLive * (act[u] * act[v]) - wDecay * w[e];
            w[e] = clamp(nw, -wMax, wMax);
          }
        }

        act.set(actNext);
      }

      function patternScore(p) {
        let dot = 0;
        for (let i = 0; i < NODE_COUNT; i++) dot += p[i] * act[i];
        return dot / NODE_COUNT;
      }

      function makePattern() {
        const center = randomPointInSphere(R * 0.75);
        const [cx, cy, cz] = center;
        const p = new Int8Array(NODE_COUNT);
        let on = 0;

        for (let i = 0; i < NODE_COUNT; i++) {
          const x = positions[i*3+0] - cx;
          const y = positions[i*3+1] - cy;
          const z = positions[i*3+2] - cz;
          const d = Math.sqrt(x*x + y*y + z*z);
          const bit = (d < patRadius) ? 1 : -1;
          p[i] = bit;
          if (bit === 1) on++;
        }
        return { p, center, radius: patRadius, onFrac: on / NODE_COUNT };
      }

      function imprint(slot) {
        liveLearningOn = false; // protect memory (toggle with L)
        const pat = makePattern();
        patterns[slot] = pat;
        targetSlot = slot;

        for (let rep = 0; rep < storeRepeats; rep++) {
          for (let e = 0; e < EDGE_COUNT; e++) {
            const u = aIdx[e], v = bIdx[e];
            let nw = w[e] + lrStore * (pat.p[u] * pat.p[v]);
            w[e] = clamp(nw, -wMax, wMax);
          }
        }

        for (let i = 0; i < NODE_COUNT; i++) {
          act[i] = pat.p[i];
          stim[i] = 0;
        }

        lastAction = `IMPRINT ${slot+1}  on≈${Math.round(pat.onFrac*100)}%  (liveLearn OFF)`;
      }

      function recall(slot) {
        const pat = patterns[slot];
        if (!pat) {
          lastAction = `RECALL ${slot+1} (empty slot)`;
          return;
        }
        targetSlot = slot;

        for (let i = 0; i < NODE_COUNT; i++) {
          const isOn = (pat.p[i] === 1);
          const keep = isOn && (Math.random() < cueFrac);
          act[i] = keep ? 1 : (Math.random() < 0.5 ? 1 : -1);
          stim[i] = 0;
        }

        for (let i = 0; i < NODE_COUNT; i++) {
          if (pat.p[i] === 1 && Math.random() < cueFrac) stim[i] = cueAmp;
        }

        for (let s = 0; s < settleSteps; s++) stepOnce({ noise: 0, learn: false });

        lastAction = `RECALL ${slot+1}  cue≈${Math.round(cueFrac*100)}%  settle=${settleSteps}  (liveLearn OFF)`;
      }

      // ---------- Persistence ----------
      function saveState() {
        try {
          const state = {
            version: 1,
            build: BUILD,
            savedAt: Date.now(),
            worldSeed: WORLD_SEED,
            nodeCount: NODE_COUNT,
            edgeCount: EDGE_COUNT,
            liveLearningOn,
            targetSlot,
            w: Array.from(w),
            patterns: patterns.map((pp) => pp ? ({
              bits: encodeBits(pp.p),
              center: pp.center,
              radius: pp.radius,
              onFrac: pp.onFrac,
            }) : null),
          };

          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
          persist.present = true;
          persist.savedAt = state.savedAt;
          persist.lastError = null;
          lastAction = `saved (${STORAGE_KEY})`;
        } catch (e) {
          persist.lastError = `save failed: ${e && e.message ? e.message : String(e)}`;
          lastAction = persist.lastError;
        }
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            lastAction = `load: no saved state (${STORAGE_KEY})`;
            return;
          }
          const state = JSON.parse(raw);

          if (!state || state.version !== 1) {
            lastAction = "load failed: wrong version";
            return;
          }
          if (state.worldSeed !== WORLD_SEED) {
            lastAction = `load failed: seed mismatch (saved ${state.worldSeed} vs world ${WORLD_SEED})`;
            return;
          }
          if (state.nodeCount !== NODE_COUNT || state.edgeCount !== EDGE_COUNT) {
            lastAction = "load failed: size mismatch";
            return;
          }
          if (!Array.isArray(state.w) || state.w.length !== EDGE_COUNT) {
            lastAction = "load failed: weights missing/mismatched";
            return;
          }

          w.set(state.w);

          // Restore patterns
          for (let i = 0; i < 3; i++) {
            const sp = state.patterns && state.patterns[i];
            if (!sp) { patterns[i] = null; continue; }
            const bits = typeof sp.bits === "string" ? sp.bits : "";
            const pBits = decodeBits(bits, NODE_COUNT);
            const center = Array.isArray(sp.center) && sp.center.length === 3 ? sp.center : [0,0,0];
            const radius = typeof sp.radius === "number" ? sp.radius : patRadius;
            const onFrac = typeof sp.onFrac === "number" ? sp.onFrac : 0;
            patterns[i] = { p: pBits, center: /** @type {[number,number,number]} */(center), radius, onFrac };
          }

          liveLearningOn = !!state.liveLearningOn;
          targetSlot = (typeof state.targetSlot === "number") ? state.targetSlot : -1;

          // Make it *visibly* loaded: show target pattern if available
          act.fill(0);
          stim.fill(0);
          lastStim = -1;
          if (targetSlot >= 0 && targetSlot < 3 && patterns[targetSlot]) {
            const pat = patterns[targetSlot];
            for (let i = 0; i < NODE_COUNT; i++) act[i] = pat.p[i];
          }

          persist.present = true;
          persist.savedAt = state.savedAt || null;
          persist.loadedAt = Date.now();
          persist.lastError = null;
          lastAction = `loaded (${STORAGE_KEY})`;
        } catch (e) {
          persist.lastError = `load failed: ${e && e.message ? e.message : String(e)}`;
          lastAction = persist.lastError;
        }
      }

      // presence check (do not auto-load; user controls it)
      try {
        persist.present = !!localStorage.getItem(STORAGE_KEY);
      } catch {
        persist.present = false;
        persist.lastError = "localStorage unavailable";
      }

      // ---------- Benchmark (B4) ----------
      const bench = { status: "idle", ui: "bench: T run | Y sweep | U cap", lastMs: null };

      function pctToScore(pct) {
        // pct = (score + 1) * 50  =>  score = pct/50 - 1
        return (pct / 50) - 1;
      }

      function medianInt(arr) {
        if (!arr.length) return null;
        const a = Array.from(arr).sort((x,y)=>x-y);
        const mid = Math.floor(a.length/2);
        return (a.length % 2) ? a[mid] : Math.round((a[mid-1] + a[mid]) / 2);
      }

      function runBenchmark(opts = {}) {
        const trials = opts.trials ?? 30;
        const thrPct = opts.thrPct ?? 75;   // success threshold
        const maxSteps = opts.maxSteps ?? 120;

        const slots = [0,1,2].filter(i => patterns[i]);
        if (!slots.length) {
          bench.status = "idle";
          bench.ui = "bench: need patterns (press 1-3)";
          lastAction = "bench: no patterns stored";
          return;
        }

        bench.status = "running";
        bench.ui = `bench: running ${trials}…`;
        lastAction = `bench running (${trials} trials)…`;

        const t0 = performance.now();

        // Save current live state so benchmark doesn't trash your scene.
        const actSave = act.slice();
        const stimSave = stim.slice();
        const liveSave = liveLearningOn;
        const targetSave = targetSlot;

        liveLearningOn = false;

        const thrScore = pctToScore(thrPct);

        let ok = 0;
        let worst = 0;
        const stepsOk = [];

        const per = [
          { total: 0, ok: 0 },
          { total: 0, ok: 0 },
          { total: 0, ok: 0 },
        ];

        for (let t = 0; t < trials; t++) {
          const slot = slots[t % slots.length]; // round-robin
          const pat = patterns[slot].p;

          per[slot].total++;

          // cue init (same spirit as recall)
          for (let i = 0; i < NODE_COUNT; i++) {
            const isOn = (pat[i] === 1);
            const keep = isOn && (Math.random() < cueFrac);
            act[i] = keep ? 1 : (Math.random() < 0.5 ? 1 : -1);
            stim[i] = 0;
          }
          for (let i = 0; i < NODE_COUNT; i++) {
            if (pat[i] === 1 && Math.random() < cueFrac) stim[i] = cueAmp;
          }

          let successStep = null;
          for (let step = 1; step <= maxSteps; step++) {
            stepOnce({ noise: 0, learn: false });
            const sc = patternScore(pat);
            if (sc >= thrScore) { successStep = step; break; }
          }

          if (successStep != null) {
            ok++;
            per[slot].ok++;
            stepsOk.push(successStep);
            if (successStep > worst) worst = successStep;
          } else {
            if (maxSteps > worst) worst = maxSteps;
          }
        }

        const t1 = performance.now();
        const ms = Math.round(t1 - t0);
        const rate = Math.round(100 * ok / trials);
        const med = medianInt(stepsOk);

        bench.status = "done";
        bench.lastMs = ms;
        bench.ui =
          `bench T=${trials} thr=${thrPct}% ok=${ok}/${trials} (${rate}%) med=${med ?? "--"} worst=${worst} ms=${ms} | ` +
          `1:${per[0].ok}/${per[0].total} 2:${per[1].ok}/${per[1].total} 3:${per[2].ok}/${per[2].total}`;

        lastAction = `bench done: ok ${ok}/${trials} (${rate}%) in ${ms}ms`;

        // Restore live state
        act.set(actSave);
        stim.set(stimSave);
        liveLearningOn = liveSave;
        targetSlot = targetSave;
      }
      function runBenchmarkSweep(opts = {}) {
        const thrPct = opts.thrPct ?? 75;
        const maxSteps = opts.maxSteps ?? 120;
        const trialsPerCue = opts.trialsPerCue ?? 24;
        const cues = opts.cues ?? [0.05, 0.10, 0.15, 0.22, 0.30, 0.40];

        const slots = [0,1,2].filter(i => patterns[i]);
        if (!slots.length) {
          bench.status = "idle";
          bench.ui = "bench: need patterns (press 1-3)";
          lastAction = "bench sweep: no patterns stored";
          return;
        }

        bench.status = "running";
        bench.ui = `bench sweep: running ${cues.length} cues…`;
        lastAction = `bench sweep running (${cues.length} cues)…`;

        const t0 = performance.now();

        // Save current live state (don't trash your scene)
        const actSave = act.slice();
        const stimSave = stim.slice();
        const liveSave = liveLearningOn;
        const targetSave = targetSlot;

        liveLearningOn = false;

        const thrScore = (thrPct / 50) - 1; // pct -> score

        function medianInt(arr) {
          if (!arr.length) return null;
          const a = Array.from(arr).sort((x,y)=>x-y);
          const mid = Math.floor(a.length/2);
          return (a.length % 2) ? a[mid] : Math.round((a[mid-1] + a[mid]) / 2);
        }

        const rows = [];
        for (const cue of cues) {
          let ok = 0;
          let worst = 0;
          const stepsOk = [];

          for (let t = 0; t < trialsPerCue; t++) {
            const slot = slots[t % slots.length];
            const pat = patterns[slot].p;

            // cue init (like recall, but cue fraction is parameter)
            for (let i = 0; i < NODE_COUNT; i++) {
              const isOn = (pat[i] === 1);
              const keep = isOn && (Math.random() < cue);
              act[i] = keep ? 1 : (Math.random() < 0.5 ? 1 : -1);
              stim[i] = 0;
            }
            for (let i = 0; i < NODE_COUNT; i++) {
              if (pat[i] === 1 && Math.random() < cue) stim[i] = cueAmp;
            }

            let successStep = null;
            for (let step = 1; step <= maxSteps; step++) {
              stepOnce({ noise: 0, learn: false });
              const sc = patternScore(pat);
              if (sc >= thrScore) { successStep = step; break; }
            }

            if (successStep != null) {
              ok++;
              stepsOk.push(successStep);
              if (successStep > worst) worst = successStep;
            } else {
              if (maxSteps > worst) worst = maxSteps;
            }
          }

          const rate = Math.round(100 * ok / trialsPerCue);
          const med = medianInt(stepsOk);
          const cuePct = String(Math.round(cue * 100)).padStart(2,"0");
          rows.push(`${cuePct}%: ${String(rate).padStart(3," ")}% / med ${String(med ?? "--").padStart(2," ")} / worst ${String(worst).padStart(2," ")}`);
        }

        const ms = Math.round(performance.now() - t0);
        bench.status = "done";
        bench.lastMs = ms;
        bench.ui =
          `bench sweep thr=${thrPct}% steps<=${maxSteps} trials/cue=${trialsPerCue} ms=${ms}\n` +
          rows.join("\n");

        lastAction = `bench sweep done in ${ms}ms`;

        // Restore live state
        act.set(actSave);
        stim.set(stimSave);
        liveLearningOn = liveSave;
        targetSlot = targetSave;
      }
      // ---------- Persistence UX (B8: legible) ----------
      function uiToggleAutoLoad() {
        const before = autoLoadOn;
        autoLoadOn = !autoLoadOn;
        localStorage.setItem(AUTOLOAD_KEY, JSON.stringify(autoLoadOn));
        toast(`AUTOLOAD ${before ? "ON" : "OFF"} -> ${autoLoadOn ? "ON" : "OFF"}`, 2200);
        lastAction = `autoload ${autoLoadOn ? "ON" : "OFF"}`;
      }

      function uiClearSavedState() {
        const had = !!localStorage.getItem(STORAGE_KEY);
        localStorage.removeItem(STORAGE_KEY);
        // keep existing persist HUD coherent if present
        try {
          if (typeof persist !== "undefined") { persist.present = false; persist.savedAt = null; persist.loadedAt = null; }
        } catch(e) {}
        const now = !!localStorage.getItem(STORAGE_KEY);
        toast(`CLEAR saved state: ${had ? "YES" : "no"} -> ${now ? "YES" : "no"}`, 2400);
        lastAction = "cleared saved state";
      }
      // ---------- Capacity / interference benchmark (B9) ----------
      function runCapacityTest(opts = {}) {
        const thrPct = opts.thrPct ?? 75;
        const maxSteps = opts.maxSteps ?? 120;
        const cue = opts.cueFrac ?? cueFrac;
        const Ns = opts.Ns ?? [1, 2, 3, 4, 6, 8, 10, 12];
        const trialsPerPattern = opts.trialsPerPattern ?? 1;

        const baseSeed = (typeof WORLD_SEED !== "undefined") ? WORLD_SEED : 1337;

        bench.status = "running";
        bench.ui = "cap: running…";
        lastAction = `cap running (thr ${thrPct}%)…`;

        const t0 = performance.now();

        // Save current live state (so cap test cannot trash your session)
        const actSave = act.slice();
        const stimSave = stim.slice();
        const wSave = w.slice();
        const liveSave = liveLearningOn;
        const targetSave = targetSlot;

        liveLearningOn = false;

        // Local deterministic RNGs
        const rnd = mulberry32(baseSeed + 9001);
        const rndW = mulberry32(baseSeed + 4242);
        function r() { return rnd(); }

        function randPointInSphereRng(radius) {
          for (;;) {
            const x = (r() * 2 - 1) * radius;
            const y = (r() * 2 - 1) * radius;
            const z = (r() * 2 - 1) * radius;
            if (x*x + y*y + z*z <= radius*radius) return [x, y, z];
          }
        }

        const maxN = Ns.reduce((a,b)=>Math.max(a,b), 0);

        // Generate a fixed pattern set once (so increasing N adds interference on the same base set)
        const pats = new Array(maxN);
        for (let pi = 0; pi < maxN; pi++) {
          const center = randPointInSphereRng(R * 0.75);
          const cx = center[0], cy = center[1], cz = center[2];
          const pb = new Int8Array(NODE_COUNT);
          for (let i = 0; i < NODE_COUNT; i++) {
            const dx = positions[i*3+0] - cx;
            const dy = positions[i*3+1] - cy;
            const dz = positions[i*3+2] - cz;
            const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
            pb[i] = (d < patRadius) ? 1 : -1;
          }
          pats[pi] = pb;
        }

        // Baseline weights shared across all N (so curve reflects interference, not different initial weights)
        const wBase = new Float32Array(EDGE_COUNT);
            // Arnold: mean-center imprint pattern
    let patMu = 0;
    for (let i = 0; i < pat.length; i++) patMu += pat[i];
    patMu /= pat.length;

for (let e = 0; e < EDGE_COUNT; e++) {
          wBase[e] = randnFrom(rndW) * 0.15;
        }

        const thrScore = (thrPct / 50) - 1;

        function medianInt(arr) {
          if (!arr.length) return null;
          const a = Array.from(arr).sort((x,y)=>x-y);
          const mid = Math.floor(a.length/2);
          return (a.length % 2) ? a[mid] : Math.round((a[mid-1] + a[mid]) / 2);
        }

        // Faster exact equivalent of stepOnce({noise:0, learn:false})
        function stepNoNoiseNoLearn() {
          for (let i = 0; i < NODE_COUNT; i++) stim[i] *= stimDecay;
          for (let i = 0; i < NODE_COUNT; i++) sum[i] = stim[i];
          for (let e = 0; e < EDGE_COUNT; e++) {
            const u = aIdx[e], v = bIdx[e];
            const we = w[e];
            const au = act[u], av = act[v];
            sum[u] += we * av;
            sum[v] += we * au;
          }
          for (let i = 0; i < NODE_COUNT; i++) {
            actNext[i] = Math.tanh(gain * (leak * act[i] + sum[i]));
          }
          act.set(actNext);
        }

        const rows = [];
        for (const N of Ns) {
          w.set(wBase);

          // Imprint first N patterns into weights (centered/covariance)

          for (let pi = 0; pi < N; pi++) {

            const pat = pats[pi];

            let mu = 0;

            for (let i = 0; i < NODE_COUNT; i++) mu += pat[i];

            mu /= NODE_COUNT;

            for (let rep = 0; rep < storeRepeats; rep++) {

              for (let e = 0; e < EDGE_COUNT; e++) {

                const u = aIdx[e], v = bIdx[e];

                const du = pat[u] - mu;

                const dv = pat[v] - mu;

                let nw = w[e] + lrStore * (du * dv);

                w[e] = clamp(nw, -wMax, wMax);

              }

            }

          }


          let ok = 0;
          let worst = 0;
          const stepsOk = [];
          const total = N * trialsPerPattern;

          for (let pi = 0; pi < N; pi++) {
            const pat = pats[pi];

            for (let tr = 0; tr < trialsPerPattern; tr++) {
              // Initialize from partial cue
              for (let i = 0; i < NODE_COUNT; i++) {
                const isOn = (pat[i] === 1);
                const keep = isOn && (r() < cue);
                act[i] = keep ? 1 : (r() < 0.5 ? 1 : -1);
                stim[i] = 0;
              }
              for (let i = 0; i < NODE_COUNT; i++) {
                if (pat[i] === 1 && r() < cue) stim[i] = cueAmp;
              }

              let successStep = null;
              for (let step = 1; step <= maxSteps; step++) {
                stepNoNoiseNoLearn();
                const sc = patternScore(pat);
                if (sc >= thrScore) { successStep = step; break; }
              }

              if (successStep != null) {
                ok++;
                stepsOk.push(successStep);
                if (successStep > worst) worst = successStep;
              } else {
                if (maxSteps > worst) worst = maxSteps;
              }
            }
          }

          const rate = Math.round(100 * ok / total);
          const med = medianInt(stepsOk);
          rows.push(`N=${String(N).padStart(2," ")}  ok ${String(rate).padStart(3," ")}%  med ${String(med ?? "--").padStart(3," ")}  worst ${String(worst).padStart(3," ")}`);
        }

        const ms = Math.round(performance.now() - t0);
        const cuePct = Math.round(cue * 100);

        bench.status = "done";
        bench.lastMs = ms;
        bench.ui =
          `cap U  rule=centered  thr=${thrPct}% cue=${cuePct}% steps<=${maxSteps} trials/pat=${trialsPerPattern} ms=${ms}\n` +
          rows.join("\n");

        lastAction = `cap done in ${ms}ms (thr ${thrPct}%)`;

        // Restore live state
        act.set(actSave);
        stim.set(stimSave);
        w.set(wSave);
        liveLearningOn = liveSave;
        targetSlot = targetSave;
      }
      // ---------- Input ----------
      const raycaster = new THREE.Raycaster();
      raycaster.params.Points.threshold = 0.22;
      const mouse = new THREE.Vector2();

      function onPointerDown(ev) {
        mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(nodes);
        if (hits && hits.length) {
          const idx = hits[0].index;
          if (idx != null) {
            stim[idx] = Math.min(2.6, stim[idx] + 1.9);
            act[idx] = 1;
            lastStim = idx;
            clickPulse = 1.0;
            clickBeacon.position.set(
              positions[idx*3+0],
              positions[idx*3+1],
              positions[idx*3+2]
            );
            clickBeacon.scale.setScalar(1.0);
            lastAction = `click stim node ${idx}`;
          }
        }
      }
      window.addEventListener('pointerdown', onPointerDown);

      function onKeyDown(ev) {
        if (ev.code === 'KeyL') { liveLearningOn = !liveLearningOn; lastAction = `live learning ${liveLearningOn ? "ON" : "OFF"}`; return; }
        if (ev.code === 'KeyR') { resetAll(); return; }

        if (ev.code === 'KeyS') { saveState(); return; }
        if (ev.code === 'KeyO') { loadState(); return; }
        if (ev.code === 'KeyA') { uiToggleAutoLoad(); return; }
        if (ev.code === 'KeyC') { uiClearSavedState(); return; }
        if (ev.code === 'KeyT') { runBenchmark(ev.shiftKey ? {thrPct: 80} : {}); return; }
        if (ev.code === 'KeyY') { runBenchmarkSweep(ev.shiftKey ? {thrPct: 80} : {}); return; }
        if (ev.code === 'KeyU') { runCapacityTest(ev.shiftKey ? {thrPct: 80} : {}); return; }

        const digitCodes = { Digit1: 0, Digit2: 1, Digit3: 2 };
        if (ev.code in digitCodes) {
          // VIZ_MEM_KEY_V1: toggle memory-slot view
          if (ev.code === "KeyM") {
            vizMemOn = !vizMemOn;
            lastAction = `MEM VIEW ${vizMemOn ? "ON" : "OFF"}`;
            if (typeof toast === "function") toast(`MEM VIEW ${vizMemOn ? "ON" : "OFF"} (M)`, 1400);
            return;
          }

          const slot = digitCodes[ev.code];
          if (ev.shiftKey) recall(slot);
          else imprint(slot);
        }
      }
      window.addEventListener('keydown', onKeyDown);

      // ---------- Visuals ----------
      function updateVisuals() {
        for (let i = 0; i < NODE_COUNT; i++) {
          const t = clamp((act[i] + 1) * 0.5, 0, 1);
          const inten = 0.26 + 0.74 * t;
          nodeColors[i*3+0] = inten;
          nodeColors[i*3+1] = inten;
          nodeColors[i*3+2] = inten;
        }
        nodesGeo.attributes.color.needsUpdate = true;

        for (let e = 0; e < EDGE_COUNT; e++) {
          const u = aIdx[e], v = bIdx[e];
          const tu = clamp((act[u] + 1) * 0.5, 0, 1);
          const tv = clamp((act[v] + 1) * 0.5, 0, 1);
          const actGate = 0.12 + 0.88 * (tu * tv);

          const wn = Math.abs(w[e]) / wMax;
          const inten = clamp(0.14 + 0.86 * wn * actGate, 0, 1);

          const r = inten * 0.22;
          const g = inten * 0.40;
          const b = inten * 1.00;

          const o = e * 6;
          edgeColors[o+0] = r; edgeColors[o+1] = g; edgeColors[o+2] = b;
          edgeColors[o+3] = r; edgeColors[o+4] = g; edgeColors[o+5] = b;
        }
        edgesGeo.attributes.color.needsUpdate = true;
      }

      // ---------- HUD ----------
      let frames = 0;
      let lastFpsT = performance.now();
      let lastHudT = performance.now();
      let fps = 0;

      function hudTick(t) {
        if (t - lastFpsT > 500) {
          fps = Math.round((frames * 1000) / (t - lastFpsT));
          frames = 0;
          lastFpsT = t;
        }

        if (t - lastHudT > 250) {
          let wAbsSum = 0;
          let wAbsMax = 0;
          for (let e = 0; e < EDGE_COUNT; e++) {
            const aw = Math.abs(w[e]);
            wAbsSum += aw;
            if (aw > wAbsMax) wAbsMax = aw;
          }
          const wAbsMean = wAbsSum / EDGE_COUNT;

          const sat = (wAbsMax >= 0.98 * wMax);
          if (sat && liveLearningOn) {
            liveLearningOn = false;
            lastAction = "auto: live learning OFF (SAT)";
          }


          const slotLabel = (i) => patterns[i] ? `${i+1}*` : `${i+1}-`;

          let bestSlot = -1;
          let bestScore = -1e9;
          const scores = [];
          for (let i = 0; i < 3; i++) {
            if (!patterns[i]) { scores.push("--"); continue; }
            const s = patternScore(patterns[i].p);
            if (s > bestScore) { bestScore = s; bestSlot = i; }
            const pct = Math.round((s + 1) * 50);
            scores.push(String(pct).padStart(3, " "));
          }

          statsLine.textContent =
            `three r${THREE.REVISION} · nodes ${NODE_COUNT} · edges ${EDGE_COUNT} · seed ${WORLD_SEED} · gl ${glStatus} · liveLearn ${liveLearningOn ? "ON" : "OFF"}\n` +
            `|w| mean ${wAbsMean.toFixed(3)} · |w|max ${wAbsMax.toFixed(3)}${sat ? " SAT" : ""} · lastStim ${lastStim >= 0 ? lastStim : "-"}`;

          memLine.textContent =
            `mem slots [${slotLabel(0)} ${slotLabel(1)} ${slotLabel(2)}]   target ${targetSlot >= 0 ? (targetSlot+1) : "-"}\n` +
            `scores  1:${scores[0]}  2:${scores[1]}  3:${scores[2]}   best ${bestSlot >= 0 ? (bestSlot+1) : "-"}:${bestSlot >= 0 ? Math.round((bestScore+1)*50) : "--"}`;

          const err = persist.lastError ? `  err: ${persist.lastError}` : "";
          persistLine.textContent =
            `persist key ${STORAGE_KEY} present ${persist.present ? "YES" : "no "}  saved ${fmtTime(persist.savedAt)}  loaded ${fmtTime(persist.loadedAt)}${err}`;

          benchLine.textContent = bench.ui;
          // sysLine (B8)
          const statePresent = !!localStorage.getItem(STORAGE_KEY);
          const nowMs = performance.now();
          if (sysToast && nowMs < sysToastUntil) {
            sysLine.textContent = `SYS: ${sysToast}`;
          } else {
            sysToast = "";
            sysLine.textContent = `SYS: autoload ${autoLoadOn ? "ON" : "OFF"}  |  savedState ${statePresent ? "YES" : "no"}  |  (A toggle, C clear)`;
          }
          actionLine.textContent = `action: ${lastAction}`;
          fpsLine.textContent = `fps ~ ${fps}`;

          lastHudT = t;
        }
      }

      // ---------- Resize ----------
      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onResize);

      // ---------- Main loop ----------
      resetAll();

      function animate(t) {
        frames++;

        group.rotation.y = t * 0.00035;
        group.rotation.x = t * 0.00018;
        // click beacon pulse (always visible)
        if (clickPulse > 0) {
          clickPulse = Math.max(0, clickPulse - 0.035);
          const p = clickPulse;
          clickBeaconMat.opacity = 0.85 * p;
          const sc = 1 + (1 - p) * 2.2;
          clickBeacon.scale.setScalar(sc);
        } else {
          clickBeaconMat.opacity = 0.0;
        }

        stepOnce({ noise: noiseAmp, learn: liveLearningOn });
        updateVisuals();
        hudTick(t);

        // VIZ_RENDER_HOOK_V1
        vizTick();
        // VIZ_MEM_RENDER_V1: memory-slot coloring overlay (when vizMemOn)
        if (vizMemOn) {
          const p0 = patterns[0] && patterns[0].p;
          const p1 = patterns[1] && patterns[1].p;
          const p2 = patterns[2] && patterns[2].p;
          for (let i = 0; i < NODE_COUNT; i++) {
            const b0 = p0 && p0[i] === 1;
            const b1 = p1 && p1[i] === 1;
            const b2 = p2 && p2[i] === 1;
            const n = (b0?1:0) + (b1?1:0) + (b2?1:0);
            let r = 0.55, g = 0.55, b = 0.55; // neutral
            if (n === 1) {
              r = b0 ? 1.00 : 0.20;
              g = b1 ? 1.00 : 0.20;
              b = b2 ? 1.00 : 0.20;
            } else if (n >= 2) {
              r = g = b = 1.00; // overlaps pop
            }
            const k = 3*i;
            nodeColors[k] = r; nodeColors[k+1] = g; nodeColors[k+2] = b;
          }
        }

        // VIZ_NODE_COLOR_NEEDSUPDATE_V1: ensure node color changes are visible
try {
  const a = nodes && nodes.geometry && nodes.geometry.getAttribute && nodes.geometry.getAttribute('color');
  if (a) a.needsUpdate = true;
} catch (e) {}


// VIZ_ACTION_FLASH_RENDER_V1
if (__vizFlashOn) {
  __arnoldEnsureColors();
  const now = performance.now();
  const t = Math.max(0, Math.min(1, (__vizFlashUntil - now) / __VIZ_FLASH_MS));
  const colAttr = nodesGeo.getAttribute('color');
  if (colAttr) {
    const arr = colAttr.array;
    const base = 0.7;
    if (t > 0) {
      for (let i = 0; i < arr.length; i += 3) {
        arr[i]     = base * (1 - t) + __vizFlashRGB[0] * t;
        arr[i + 1] = base * (1 - t) + __vizFlashRGB[1] * t;
        arr[i + 2] = base * (1 - t) + __vizFlashRGB[2] * t;
      }
      colAttr.needsUpdate = true;
      __vizFlashLastActive = true;
    } else if (__vizFlashLastActive) {
      for (let i = 0; i < arr.length; i += 3) {
        arr[i] = base; arr[i + 1] = base; arr[i + 2] = base;
      }
      colAttr.needsUpdate = true;
      __vizFlashLastActive = false;
    }
  }
}

renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
        // autoload once (B8)
        if (!autoLoadAttempted) {
          autoLoadAttempted = true;
          if (autoLoadOn && localStorage.getItem(STORAGE_KEY)) {
            loadState();
            toast("AUTOLOAD: loaded saved state", 2200);
            lastAction = "auto-load";
          } else if (autoLoadOn) {
            toast("AUTOLOAD: ON (no saved state)", 2200);
          }
        }
    }).catch((e) => {
      fallback.style.display = 'flex';
      fallback.innerHTML = `
        <div>
          <div style="font-weight:700; font-size:18px; margin-bottom:10px;">
            Three.js failed to load.
          </div>
          <div style="opacity:0.9; max-width: 740px;">
            Open DevTools → Console and copy the first red error line.
          </div>
        </div>
      `;
      console.error(e);
    });
  </script>
</body>
</html>
