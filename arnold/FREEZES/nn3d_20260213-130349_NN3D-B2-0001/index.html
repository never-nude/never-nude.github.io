<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NN3D Lab</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #hud {
      position: fixed; top: 12px; left: 12px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      color: #fff;
      font: 13px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      user-select: none;
      z-index: 10;
      min-width: 360px;
      white-space: pre;
    }
    #hud .build { font-size: 16px; font-weight: 700; letter-spacing: 0.3px; }
    #hud .row { opacity: 0.92; }
    #fallback {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      color: #fff;
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      padding: 24px; text-align: center;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="build" id="buildLine">BUILD:</div>
    <div class="row" id="urlLine"></div>
    <div class="row" id="statsLine"></div>
    <div class="row" id="memLine"></div>
    <div class="row" id="actionLine"></div>
    <div class="row" id="helpLine"></div>
    <div class="row" id="fpsLine"></div>
  </div>

  <div id="fallback"></div>

  <script type="module">
    const BUILD = "NN3D-B2-0001"; // Associative Memory Mode (store/recall patterns)

    const buildLine  = document.getElementById('buildLine');
    const urlLine    = document.getElementById('urlLine');
    const statsLine  = document.getElementById('statsLine');
    const memLine    = document.getElementById('memLine');
    const actionLine = document.getElementById('actionLine');
    const helpLine   = document.getElementById('helpLine');
    const fpsLine    = document.getElementById('fpsLine');
    const fallback   = document.getElementById('fallback');

    buildLine.textContent = `BUILD: ${BUILD}`;
    urlLine.textContent = location.href;
    helpLine.textContent =
      "Click=stimulate  |  L=toggle live learning  |  R=reset all\n" +
      "1-3=IMPRINT pattern  |  Shift+1-3=RECALL from partial cue";

    console.log(`[NN3D] BUILD ${BUILD}`, location.href);

    // CDN fallback chain
    const threeUrls = [
      'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
      'https://unpkg.com/three@0.160.0/build/three.module.js',
    ];

    let p = import(threeUrls[0]);
    for (let i = 1; i < threeUrls.length; i++) p = p.catch(() => import(threeUrls[i]));

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function randn() {
      // Box-Muller
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function randomPointInSphere(radius) {
      // rejection sampling
      for (;;) {
        const x = (Math.random() * 2 - 1) * radius;
        const y = (Math.random() * 2 - 1) * radius;
        const z = (Math.random() * 2 - 1) * radius;
        if (x*x + y*y + z*z <= radius*radius) return [x, y, z];
      }
    }

    p.then((THREE) => {
      // ---------- Scene ----------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 200);
      camera.position.set(0, 0, 7);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.display = 'block';
      document.body.appendChild(renderer.domElement);

      // ---------- Network geometry ----------
      const NODE_COUNT = 260;
      const K = 3;       // edges chosen per node; treated as undirected in dynamics
      const R = 2.4;

      // Node positions
      const positions = new Float32Array(NODE_COUNT * 3);
      for (let i = 0; i < NODE_COUNT; i++) {
        const u = Math.random();
        const v = Math.random();
        const w = Math.random();

        const r = Math.cbrt(u) * R;
        const theta = 2 * Math.PI * v;
        const phi = Math.acos(2 * w - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i*3+0] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;
      }

      // Edges (pairs). We keep the same segment count as B1: NODE_COUNT * K
      const EDGE_COUNT = NODE_COUNT * K;
      const aIdx = new Uint16Array(EDGE_COUNT);
      const bIdx = new Uint16Array(EDGE_COUNT);

      for (let i = 0; i < NODE_COUNT; i++) {
        for (let k = 0; k < K; k++) {
          const e = i * K + k;
          let j = (i + 1 + Math.floor(Math.random() * (NODE_COUNT - 1))) % NODE_COUNT;
          aIdx[e] = i;
          bIdx[e] = j;
        }
      }

      // Edge vertex positions (2 vertices per segment)
      const edgePos = new Float32Array(EDGE_COUNT * 2 * 3);
      for (let e = 0; e < EDGE_COUNT; e++) {
        const u = aIdx[e], v = bIdx[e];
        const o = e * 6;
        edgePos[o+0] = positions[u*3+0];
        edgePos[o+1] = positions[u*3+1];
        edgePos[o+2] = positions[u*3+2];
        edgePos[o+3] = positions[v*3+0];
        edgePos[o+4] = positions[v*3+1];
        edgePos[o+5] = positions[v*3+2];
      }

      // Node colors (per-vertex)
      const nodeColors = new Float32Array(NODE_COUNT * 3);
      for (let i = 0; i < NODE_COUNT; i++) {
        nodeColors[i*3+0] = 0.15;
        nodeColors[i*3+1] = 0.15;
        nodeColors[i*3+2] = 0.15;
      }

      const nodesGeo = new THREE.BufferGeometry();
      nodesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      nodesGeo.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));

      const nodesMat = new THREE.PointsMaterial({
        size: 0.055,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
      });

      const nodes = new THREE.Points(nodesGeo, nodesMat);

      // Edge colors (per-vertex): 2 vertices per segment
      const edgeColors = new Float32Array(EDGE_COUNT * 2 * 3);
      for (let i = 0; i < edgeColors.length; i += 3) {
        edgeColors[i+0] = 0.05;
        edgeColors[i+1] = 0.08;
        edgeColors[i+2] = 0.18;
      }

      const edgesGeo = new THREE.BufferGeometry();
      edgesGeo.setAttribute('position', new THREE.BufferAttribute(edgePos, 3));
      edgesGeo.setAttribute('color', new THREE.BufferAttribute(edgeColors, 3));

      const edgesMat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.52,
      });

      const edgeLines = new THREE.LineSegments(edgesGeo, edgesMat);

      const group = new THREE.Group();
      group.add(edgeLines);
      group.add(nodes);
      scene.add(group);

      // Faint sphere (depth cue)
      const glowGeo = new THREE.SphereGeometry(R*1.02, 32, 32);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x224466, transparent: true, opacity: 0.08 });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);

      // ---------- Learning engine ----------
      // Activation domain is [-1, +1]. We map brightness from (a+1)/2 so patterns become visibly "on/off".
      const act = new Float32Array(NODE_COUNT);
      const actNext = new Float32Array(NODE_COUNT);
      const stim = new Float32Array(NODE_COUNT);
      const sum = new Float32Array(NODE_COUNT);

      // One weight per undirected edge
      const w = new Float32Array(EDGE_COUNT);
      const wMax = 2.0;

      // Live dynamics (used every frame)
      let liveLearningOn = true;
      const stimDecay = 0.90;
      const noiseAmp = 0.006;
      const leak = 0.20;
      const gain = 1.25;

      // Live learning (slow drift; can be toggled off)
      const lrLive = 0.010;
      const wDecay = 0.0015;

      // Memory imprint / recall parameters
      const patRadius = R * 0.65;   // makes “blob-like” patterns
      const lrStore = 0.10;         // strong, visible imprint
      const storeRepeats = 3;       // small loop, fast but strong
      const cueFrac = 0.22;         // fraction of ON bits shown in cue
      const cueAmp = 1.6;           // how strongly the cue holds initially
      const settleSteps = 36;       // settle quickly after recall

      let lastAction = "ready";
      let lastStim = -1;

      // Patterns: 3 slots
      /** @type {Array<null | {p:Int8Array, center:[number,number,number], radius:number, onFrac:number}>} */
      const patterns = [null, null, null];
      let targetSlot = -1; // 0..2 or -1

      function resetAll() {
        for (let i = 0; i < NODE_COUNT; i++) {
          act[i] = 0;
          actNext[i] = 0;
          stim[i] = 0;
        }
        for (let e = 0; e < EDGE_COUNT; e++) w[e] = randn() * 0.15;
        patterns[0] = patterns[1] = patterns[2] = null;
        targetSlot = -1;
        lastStim = -1;
        lastAction = "reset all";
      }

      resetAll();

      function stepOnce(opts = { noise: noiseAmp, learn: liveLearningOn }) {
        const noise = opts.noise ?? noiseAmp;
        const learn = opts.learn ?? liveLearningOn;

        // stimulus decay
        for (let i = 0; i < NODE_COUNT; i++) stim[i] *= stimDecay;

        // start sums with stimulus + noise
        for (let i = 0; i < NODE_COUNT; i++) sum[i] = stim[i] + noise * randn();

        // undirected propagation: edge (u,v) contributes to both ends
        for (let e = 0; e < EDGE_COUNT; e++) {
          const u = aIdx[e], v = bIdx[e];
          const we = w[e];
          const au = act[u], av = act[v];
          sum[u] += we * av;
          sum[v] += we * au;
        }

        for (let i = 0; i < NODE_COUNT; i++) {
          actNext[i] = Math.tanh(gain * (leak * act[i] + sum[i]));
        }

        if (learn) {
          for (let e = 0; e < EDGE_COUNT; e++) {
            const u = aIdx[e], v = bIdx[e];
            // Hebbian drift: Δw ~ a_u * a_v
            let nw = w[e] + lrLive * (act[u] * act[v]) - wDecay * w[e];
            w[e] = clamp(nw, -wMax, wMax);
          }
        }

        act.set(actNext);
      }

      function patternScore(p) {
        // dot / N -> roughly [-1..1]
        let dot = 0;
        for (let i = 0; i < NODE_COUNT; i++) dot += p[i] * act[i];
        return dot / NODE_COUNT;
      }

      function makePattern() {
        const center = randomPointInSphere(R * 0.75);
        const [cx, cy, cz] = center;
        const p = new Int8Array(NODE_COUNT);
        let on = 0;

        for (let i = 0; i < NODE_COUNT; i++) {
          const x = positions[i*3+0] - cx;
          const y = positions[i*3+1] - cy;
          const z = positions[i*3+2] - cz;
          const d = Math.sqrt(x*x + y*y + z*z);
          const bit = (d < patRadius) ? 1 : -1;
          p[i] = bit;
          if (bit === 1) on++;
        }

        return { p, center, radius: patRadius, onFrac: on / NODE_COUNT };
      }

      function imprint(slot) {
        const pat = makePattern();
        patterns[slot] = pat;
        targetSlot = slot;

        // Strong symmetric Hebbian imprint on sparse graph:
        for (let rep = 0; rep < storeRepeats; rep++) {
          for (let e = 0; e < EDGE_COUNT; e++) {
            const u = aIdx[e], v = bIdx[e];
            let nw = w[e] + lrStore * (pat.p[u] * pat.p[v]);
            w[e] = clamp(nw, -wMax, wMax);
          }
        }

        // Show the stored pattern immediately in activity (visible blob)
        for (let i = 0; i < NODE_COUNT; i++) {
          act[i] = pat.p[i];
          stim[i] = 0;
        }

        lastAction = `IMPRINT ${slot+1}  on≈${Math.round(pat.onFrac*100)}%`;
      }

      function recall(slot) {
        const pat = patterns[slot];
        if (!pat) {
          lastAction = `RECALL ${slot+1} (empty slot)`;
          return;
        }
        targetSlot = slot;

        // Start from a corrupted state:
        // - for a fraction of ON bits, keep correct (+1)
        // - elsewhere, random ±1
        for (let i = 0; i < NODE_COUNT; i++) {
          const isOn = (pat.p[i] === 1);
          const keep = isOn && (Math.random() < cueFrac);
          act[i] = keep ? 1 : (Math.random() < 0.5 ? 1 : -1);
          stim[i] = 0;
        }

        // Hold cue bits briefly via stimulus
        for (let i = 0; i < NODE_COUNT; i++) {
          if (pat.p[i] === 1 && Math.random() < cueFrac) stim[i] = cueAmp;
        }

        // Settle quickly (no noise, no live learning during settle)
        for (let s = 0; s < settleSteps; s++) stepOnce({ noise: 0, learn: false });

        lastAction = `RECALL ${slot+1}  cue≈${Math.round(cueFrac*100)}%  settle=${settleSteps}`;
      }

      // Click → stimulate nearest node
      const raycaster = new THREE.Raycaster();
      raycaster.params.Points.threshold = 0.14;
      const mouse = new THREE.Vector2();

      function onPointerDown(ev) {
        mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(ev.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(nodes);
        if (hits && hits.length) {
          const idx = hits[0].index;
          if (idx != null) {
            stim[idx] = Math.min(2.6, stim[idx] + 1.9);
            act[idx] = 1;
            lastStim = idx;
            lastAction = `click stim node ${idx}`;
          }
        }
      }
      window.addEventListener('pointerdown', onPointerDown);

      // Keys:
      // - L toggles live learning drift
      // - R resets all (weights + stored patterns)
      // - 1/2/3 imprint
      // - Shift+1/2/3 recall
      function onKeyDown(ev) {
        // Note: Shift+1 usually produces ev.key="!" but ev.code="Digit1" stays stable.
        if (ev.code === 'KeyL') {
          liveLearningOn = !liveLearningOn;
          lastAction = `live learning ${liveLearningOn ? "ON" : "OFF"}`;
          return;
        }
        if (ev.code === 'KeyR') {
          resetAll();
          return;
        }

        const digitCodes = { Digit1: 0, Digit2: 1, Digit3: 2 };
        if (ev.code in digitCodes) {
          const slot = digitCodes[ev.code];
          if (ev.shiftKey) recall(slot);
          else imprint(slot);
        }
      }
      window.addEventListener('keydown', onKeyDown);

      function updateVisuals() {
        // Node brightness from (a+1)/2 so +1 is bright, -1 is dim.
        for (let i = 0; i < NODE_COUNT; i++) {
          const t = clamp((act[i] + 1) * 0.5, 0, 1);
          const inten = 0.08 + 0.92 * t;
          nodeColors[i*3+0] = inten;
          nodeColors[i*3+1] = inten;
          nodeColors[i*3+2] = inten;
        }
        nodesGeo.attributes.color.needsUpdate = true;

        // Edge intensity from |w|, gated by endpoint brightness
        for (let e = 0; e < EDGE_COUNT; e++) {
          const u = aIdx[e], v = bIdx[e];
          const tu = clamp((act[u] + 1) * 0.5, 0, 1);
          const tv = clamp((act[v] + 1) * 0.5, 0, 1);
          const actGate = 0.12 + 0.88 * (tu * tv);

          const wn = Math.abs(w[e]) / wMax;
          const inten = clamp(0.02 + 0.98 * wn * actGate, 0, 1);

          // calm bluish intensity (color semantics = strength)
          const r = inten * 0.22;
          const g = inten * 0.40;
          const b = inten * 1.00;

          const o = e * 6;
          edgeColors[o+0] = r; edgeColors[o+1] = g; edgeColors[o+2] = b;
          edgeColors[o+3] = r; edgeColors[o+4] = g; edgeColors[o+5] = b;
        }
        edgesGeo.attributes.color.needsUpdate = true;
      }

      // ---------- HUD ----------
      let frames = 0;
      let lastFpsT = performance.now();
      let lastHudT = performance.now();
      let fps = 0;

      function hudTick(t) {
        if (t - lastFpsT > 500) {
          fps = Math.round((frames * 1000) / (t - lastFpsT));
          frames = 0;
          lastFpsT = t;
        }

        if (t - lastHudT > 250) {
          // Weight stats
          let wAbsSum = 0;
          let wAbsMax = 0;
          for (let e = 0; e < EDGE_COUNT; e++) {
            const aw = Math.abs(w[e]);
            wAbsSum += aw;
            if (aw > wAbsMax) wAbsMax = aw;
          }
          const wAbsMean = wAbsSum / EDGE_COUNT;

          // Memory status + scores
          const slotLabel = (i) => patterns[i] ? `${i+1}*` : `${i+1}-`;

          let bestSlot = -1;
          let bestScore = -1e9;
          const scores = [];
          for (let i = 0; i < 3; i++) {
            if (!patterns[i]) {
              scores.push("--");
              continue;
            }
            const s = patternScore(patterns[i].p); // [-1..1]
            if (s > bestScore) { bestScore = s; bestSlot = i; }
            const pct = Math.round((s + 1) * 50); // 0..100
            scores.push(String(pct).padStart(3, " "));
          }

          statsLine.textContent =
            `three r${THREE.REVISION} · nodes ${NODE_COUNT} · edges ${EDGE_COUNT} · liveLearn ${liveLearningOn ? "ON" : "OFF"}\n` +
            `|w| mean ${wAbsMean.toFixed(3)} · |w|max ${wAbsMax.toFixed(3)} · lastStim ${lastStim >= 0 ? lastStim : "-"}`;

          memLine.textContent =
            `mem slots [${slotLabel(0)} ${slotLabel(1)} ${slotLabel(2)}]   target ${targetSlot >= 0 ? (targetSlot+1) : "-"}\n` +
            `scores  1:${scores[0]}  2:${scores[1]}  3:${scores[2]}   best ${bestSlot >= 0 ? (bestSlot+1) : "-"}:${bestSlot >= 0 ? Math.round((bestScore+1)*50) : "--"}`;

          actionLine.textContent = `action: ${lastAction}`;
          fpsLine.textContent = `fps ~ ${fps}`;

          lastHudT = t;
        }
      }

      // ---------- Resize ----------
      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onResize);

      // ---------- Main loop ----------
      function animate(t) {
        frames++;

        // obvious motion (identity probe)
        group.rotation.y = t * 0.00035;
        group.rotation.x = t * 0.00018;

        stepOnce({ noise: noiseAmp, learn: liveLearningOn });
        updateVisuals();
        hudTick(t);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    }).catch((e) => {
      fallback.style.display = 'flex';
      fallback.innerHTML = `
        <div>
          <div style="font-weight:700; font-size:18px; margin-bottom:10px;">
            Three.js failed to load.
          </div>
          <div style="opacity:0.9; max-width: 740px;">
            Open DevTools → Console and copy the first red error line.
          </div>
        </div>
      `;
      console.error(e);
    });
  </script>
</body>
</html>
